// RUN: rm -f %t.ll %t.dev.ll
// RUN: %mim %s --output-ll %t.ll --output-device-ll %t.dev.ll --device-target nvptx -o -
// RUN: rm -f %t.obj
// RUN: llc -filetype=obj -relocation-model=pic %t.ll -o %t.obj
// RUN: rm -f %t
// RUN: clang %t.obj -o %t -lcuda
// RUN: rm -f %t.ptx
// RUN: llc -march=nvptx64 %t.dev.ll -o %t.ptx
// RUN: rm -f %t.cubin
// RUN: ptxas %t.ptx -o %t.cubin
// RUN: rm -f %t.fatbin
// RUN: nvcc -fatbin %t.cubin -o %t.fatbin
// TODO: this does not work yet because of hard-coded fatbin file name
// RUN: %t; test $? -eq 44
// RUN: %t 1 2 3; test $? -eq 44
// RUN: %t 1 2 3 4 5; test $? -eq 44

plugin core;
plugin gpu;
plugin nvptx;

con extern kernel [m1: %mem.M 1, m3: %mem.M 3, m4: %mem.M 4, m5: %mem.M 5,
                   warp_id: Idx 4, thread_id: Idx 4, data: %gpu.GlobalPtr «4; I32»,
                   return: Cn [m1: %mem.M 1, m3: %mem.M 3, m4: %mem.M 4, m5: %mem.M 5]] =
    let el = %mem.lea (data, thread_id);
    let val = %core.bitcast I32 thread_id;
    let val = %core.wrap.add 0 (val, 42I32);
    let m1 = %mem.store (m1, el, val);
    return (m1, m3, m4, m5);

con extern main [m0: %mem.M 0, m1: %mem.M 1,
                 argc: I32, argv: %mem.Ptr («⊤:Nat; %mem.Ptr («⊤:Nat; I8», 0)», 0),
                 return: Cn [%mem.M 0, %mem.M 1, I32]] =
    let (m0, arr) = %mem.alloc («4; I32», 0) m0;

    let arr_0 = %mem.lea (arr, 0_4);
    let m0 = %mem.store (m0, arr_0, argc);
    let arr_1 = %mem.lea (arr, 1_4);
    let m0 = %mem.store (m0, arr_1, argc);
    let arr_2 = %mem.lea (arr, 2_4);
    let m0 = %mem.store (m0, arr_2, argc);
    let arr_3 = %mem.lea (arr, 3_4);
    let m0 = %mem.store (m0, arr_3, argc);

    let (m1, d_ptr) = %mem.alloc («4; I32», 1) m1;
    let (m0, m1) = %gpu.copy_mem_to_device (m0, m1, arr, d_ptr);

    let m0 = %gpu.launch (4, 4) (m0, kernel, d_ptr);

    let (m0, m1) = %gpu.copy_mem_to_host (m0, m1, d_ptr, arr);
    let m1 = %mem.free (m1, d_ptr);

    let (m0, val) = %mem.load (m0, arr_2);
    let m0 = %mem.free (m0, arr);

    return (m0, m1, val);
