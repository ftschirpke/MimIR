// RUN: rm -f %t.ll %t.dev.ll
// RUN: %mim %s --output-ll %t.ll --output-device-ll %t.dev.ll --device-target nvptx -o -
// RUN: rm -f %t.obj
// RUN: llc -filetype=obj -relocation-model=pic %t.ll -o %t.obj
// RUN: rm -f %t
// RUN: clang %t.obj -o %t -lcuda
// RUN: rm -f %t.ptx
// RUN: llc -march=nvptx64 %t.dev.ll -o %t.ptx
// RUN: rm -f %t.cubin
// RUN: ptxas %t.ptx -o %t.cubin
// RUN: rm -f %t.fatbin
// RUN: nvcc -fatbin %t.cubin -o %t.fatbin
// TODO: this does not work yet because of hard-coded fatbin file name
// RUN: %t; test $? -eq 42
// RUN: %t 1 2 3; test $? -eq 42
// RUN: %t 1 2 3 4 5; test $? -eq 42

plugin core;
plugin gpu;
plugin nvptx;

con extern kernel [mem: %gpu.M, warp_id: Idx 1, thread_id: Idx 4, data: %gpu.GlobalPtr I32, return: Cn %gpu.M] =
    let mem = %gpu.store (mem, data, 42I32);
    return mem;

con extern main [mem: %mem.M, argc: I32, argv: %mem.Ptr («⊤:Nat; %mem.Ptr («⊤:Nat; I8», 0)», 0), return: Cn [%mem.M, I32]] =
    let (mem, ptr) = %mem.alloc (I32, 0) mem;
    let mem = %mem.store (mem, ptr, argc);

    let (mem, d_ptr) = %mem.alloc (I32, 1) mem;
    let mem = %gpu.copy_mem_to_device (mem, ptr, d_ptr);

    let mem = %gpu.launch (mem, 1, 4, kernel, d_ptr);

    let mem = %gpu.copy_mem_to_host (mem, d_ptr, ptr);
    let mem = %mem.free (mem, d_ptr);

    let (mem, val) = %mem.load (mem, ptr);
    let mem = %mem.free (mem, ptr);

    return (mem, val);
